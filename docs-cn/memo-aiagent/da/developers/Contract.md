# 验证合约

Meeda的验证合约主要由FileProof实现。接下来将具体讲解FileProof的设计细节，以供开发者探讨。

## 背景

Layer2节点经过DABackend节点上传文件，Meeda的DA层保证文件的可用性。Layer2节点需要向DABackend节点付费，以维持数据可用性服务。

FileProof作为Meeda的数据可用性层，它是Meeda的智能合约部分，充当去中心化的监管者。DABackend节点需要定期往链上提交数据可用性证明，证明通过则可以认为Layer2节点数据的可用性得到保障，DABackend节点从而可以获得相应的服务费用，证明失败，则DABackend节点无法获取相应的服务费用，该笔费用将发放给基金会，用于开发维护更加稳定可靠的服务平台。

为了减少数据可用性证明的开销、提高数据可用性证明的效率，FileProof从Layer2中Optimistic Rollup获得灵感，实现了适用于文件可用性证明的乐观验证和多轮交互式欺诈证明方案。并且利用KZG多项式承诺技术，使得验证方式高效且低成本。从而提供一种简洁高效、低成本、可扩展性强、去中心化的DA解决方案。

### 技术背景

应用bls12-381曲线和kzg多项式承诺技术。

通过多方计算生成一个私密参数s，公开 `ψ=s*g_2`，也就是验证公钥vk；并且公开`s_i = s^i*g_1`。其中，`g_2`是bls12_381曲线的G2生成元，`g_1`是bls12_381曲线的G1生成元。

对于要被证明的数据，可以将其看作是向量P: {p0, p1, ... , `p_{n-1}` }，其中pi ∈ Fr，大小不超过32字节，可以将数据分割为32字节的atoms，然后将每一个atom转换为Fr元素。

然后将向量P构建成一个多项式 `P(x) = \sum_{i=0}^{n-1}p_ix^i` ，之后得到该文件的承诺C，`C = P(s)g_1 = \sum_{i=0}^{n-1}p_i s_i` ，C是一个G1点。

证明：

证明者需要提供数据P的持有证明proof。

验证者给定一个随机数z（bytes32），数据拥有者也就是证明者可以计算：`y = P(z)`，并且取多项式`Q(x) = \frac{P(x)-y}{x-z}`，其中，`Q(x) = \frac{P(x)-y}{x-z} = \sum_{i=0}^{n-2}q_ix^i`，其中， `q_{n-2} = p_{n-1}` ，`q_i = p_{i+1} + q_{i+1} * y` 。

从而计算：`π = Q(s)g_1 = \sum_{i=0}^{n-2}q_is_i`

证明proof即为 （`y`，`π`）。

验证：

验证者在不知道数据的情况下，即在不知道向量P的情况下，根据公开参数`ψ` 、z、y、 `π` 、 `C`，验证证明者确实知道数据。验证者根据bls12_381的线性配对性质，验证`e(π, ψ-z*g_2) = e(C - y*g_1, g_2)`即可，如果验证通过，则可以确定证明者知道数据P，否则证明者不知道数据P。

批量证明：

在同一个随机数z的情况下，证明者提供批量证明。批量生成各个文件的承诺`C_j`以及证明（`y_j`， `π_j` ）。设`ϕ = y*g_1`，则聚合承诺Cn、聚合证明（`ϕ`，`π`）依次为：

`C = \sum_{j=0}^{m-1}C_j`

`ϕ = \sum_{j=0}^{m-1}ϕ_j`

`π=\sum_{i=0}^{m-1}π_j`

验证者依然是验证：`e(π, ψ-z*g_2) = e(C - ϕ, g_2)`。

## 流程

### 1. 上传文件

#### 1.1 链下

Layer2节点上传文件，DABackend节点返回给Layer2节点一个文件已上传的凭证`credential`以及一个文件唯一识别符`commitment`（即由该文件产生的多项式承诺）。

其中，`commitment`是一个G1元素，96字节长度，x坐标48字节，y坐标48字节。在合约中用bytes32[4]格式表示一个G1元素的Affine坐标格式，前两个bytes32表示x坐标，后两个bytes32表示y坐标，x、y均为大端编码格式，并且bytes32[2]的最前面16个字节全部填充0。

文件已上传的凭据可以是DABackend节点的一个签名，签名内容应包含FileProof的合约地址（以防以后更换合约导致该签名有被重复利用的风险）、Layer2节点地址（上传文件者，即文件拥有者）、文件`commitment`、文件`size`（单位Byte）、文件存储起始时间`start`（用时间戳表示）、文件存储结束时间`end`，文件到期后DABackend节点不需要再提供该文件的可用性证明。获得签名内容后，DABackend节点用私钥进行签名，从而保障文件确实已经成功上传至存储节点，否则，Layer2节点可能会提交一个并未上传的文件`commitment`至合约，DABackend节点后续无法提供该文件的可用性证明，从而受到不应该有的惩罚。

签名内容的哈希计算方式：

`bytes32 hash = keccak256(abi.encodePacked(fileProofAddr, caller, commitment, sizeByte, start, end));`

#### 1.2 链上

Layer2节点调用合约中的`addFile`方法将文件`commitment`保存到链上，用于后续DABackend节点提供文件可用性证明。

合约验证凭据`credential`，验证通过则可以将文件`commitment`保存在合约中（DABackend节点将会定期向合约提交部分文件的可用性证明），并且Layer2节点需要为文件可用性服务付费。费用统一由合约账户保管。服务单价为`price`（单位是attomemo/byte/second，服务费用`value = size * price * (end - start)`），会被记录在合约中，并且可以由基金会成员根据实际情况生成多签进行修改，修改`price`不会影响到已经上传的文件。

> 这里之所以规定只提交部分文件的可用性证明，而不是提交全部文件的可用性证明，是因为若规定每次提交全部文件的可用性证明，那么DABackend节点不需要保存文件数据本身，只保存所有文件的多项式参数之和就能应付定期证明提交。而规定每次随机抽查部分文件，则可以使DABackend节点必须保存文件数据，这样才能根据文件以及随机数，生成被随机抽查部分文件的可用性证明，从而通过定期证明提交。

Layer2节点无法再次上传一个已经存在的文件`commitment`。

每次上传`commitment`时，都需要维护最后有效期`finalExpire`，它表示所有文件都到期的时间。在`finalExpire`后，DABackend节点不再需要提交可用性证明，DABackend节点也不会再获得收益。

### 2. 提交证明

所有上传的文件，其`commitment`以及有效期`end`都保存在链上。针对未到期的文件，DABackend节点需定期往链上提交可用性证明，从而可以获得相应的服务费用。证明通过，则可以视为在一定程度上（抽样检测无法百分百保证）Layer2节点数据的可用性得到保障。

#### 2.1 生成随机数

根据kzg多项式承诺方案以及去中心化特性，将由合约定期生成一个伪随机数`rnd`，合约将根据`rnd`确定本段时期被抽查的文件，之后，DABackend节点根据`rnd`对被抽查的文件生成可用性证明，合约也根据`rnd`对该证明进行验证。

需要保证该伪随机数无法预测，如果随机数能够被预测，那么DABackend节点可以做出恶意行为从而提前知道待验证的文件，进而提前准备可用性证明，而不需要一直完整保存Layer2节点数据，在这种情况下，Layer2节点数据的可用性无法得到可靠的保障。因此，每一段时期内的随机数需要在可以开始提交可用性证明的特定短时期内生成。

因此，除了确定提交可用性证明的间隔时间`interval`外，还需要确定一个提交证明的有效时期`period`。每隔一段时间`interval`，DABackend节点需要在有效时期`period`内提交证明。DABackend节点在有效时期`period`内未提交证明，则可以视为DABackend节点在该段时期`interval`内未履行保障Layer2节点数据可用性的协议，DABackend节点则无法获取该段时间的服务收益。

DABackend节点每次提交可用性证明需要用到的随机数`rnd`，也只能在间隔时间`interval`后、有效时期`period`内生成，一旦生成，在该段时期`period`内不可更改，超过了有效时期`period`，该随机数`rnd`将失效。

DABackend节点提交证明的间隔时间`interval`以及提交证明的有效期`period`由基金会成员讨论决定，在部署合约时指定，且后续可根据实际情况进行更改。

#### 2.2 挑选待验证文件

在提交证明的有效时期`period`内，合约才会生成此次的有效随机数`rnd`，根据该随机数`rnd`再确定挑选哪些文件进行验证。DABackend节点需要生成这些文件的可用性证明并聚合，之后将聚合证明提交到合约中进行验证（将采取乐观和多轮交互的方式进行验证，该部分内容将在后面详细讲解）。

DABackend节点需要保证和合约使用相同的算法来获取待验证文件，或者直接从合约提供的接口进行查询，否则验证将总是失败。每次挑选的文件总数由`chalSum`指定，`chalSum`是根据系统中的文件总数经过一定的概率计算得出的。这里暂时不考虑系统中已过期的文件数，后期Meeda将考虑到这个情况，使得该解决方案更加简洁高效。

查询该段时期哪些文件被挑选的功能由合约中的接口`selectFiles(uint i)`实现。

由`rnd`、文件总数`length`以及待挑选文件的索引`i`[0, chalSum)，得到将要被挑选的文件的承诺值（如果被选中的文件已过期，那么承诺值为0），根据kzg多项式承诺，对被选中的文件生成相应的可用性证明，将所有可用性证明聚合得到`Pn`，将被选中文件的commitments聚合得到`Cn`。

上次提交证明时间记为`last`，那么这次提交证明的截止时间则为`last+interval+period`。每个验证期挑选文件时，文件存储结束时间`end`不超过`last`的，都视为已到期文件。

#### 2.3 生成证明并提交

DABackend节点在链下获得被挑选的待验证文件的数据持有证明，聚合这些证明，将聚合证明`Pn`和聚合承诺`Cn`提交到链上。DABackend节点需要保证使用的随机数是有效的，即和合约中生成的有效随机数一致。

乐观验证即假设DABackend节点提交的`Cn`（被挑选文件的聚合承诺）是正确的，只需要验证`Pn`对`Cn`的正确性即可。在规定的有效期内，若没有节点（任意节点）提出对`Cn`的质疑，那么该次可用性证明则视为成功。如果有节点提出质疑，该节点就往链上发起挑战（该节点被称为挑战者），后续则触发多轮交互验证`Cn`的正确性，验证通过，该次可用性证明才被视为成功。这一逻辑将在欺诈证明中详细讲解。

如果DABackend节点提交的证明`Pn`通过验证，那么本次验证期（也就是`<last_pre, last_now>`）应获得的服务收益`thisProfit = balance * (last_now - last_pre) / (finalExpire - last_pre)`，其中`balance`表示合约账户的有效余额（Layer2节点上传文件时将服务费用交由合约账户保管，每次提交可用性证明时线性释放给DABackend节点）。为了支持代价更小的多轮交互式验证方式并且激励DABackend节点提供更好的服务，服务收益采取延期释放的方式。也就是说，本次提交可用性证明应获得的收益将会在下一次提交证明时释放。无论本次可用性证明的验证是否通过，合约账户都会将上一次提交可用性证明时应得的收益释放给DABackend节点。

### 3. 欺诈证明

DABackend节点定时提交可用性证明后，为了减少验证的代价，采用了乐观验证方式。即只针对聚合承诺`Pn`进行验证，若失败，则直接表明本次验证失败；若成功，则任意节点可以选择进一步对`Cn`提出质疑。因为第一阶段只是假设DABackend节点不存在欺诈行为，也就是假设`Cn`是正确的。如果任意节点在链下计算的过程中发现`Cn`是错误的，则可以在链上提出对`Cn`的质疑，从而发起挑战。挑战成功，则挑战者获得经济奖励；挑战失败（也就是说`Cn`确实是正确的），则挑战者将失去挑战时质押的资金。节点提出质疑并发起挑战最终得到挑战结果的这一过程就称为欺诈证明。

第一阶段是证明`Pn`对`Cn`的正确性，第二阶段的欺诈证明就是证明`Cn`的正确性。为了减少链上的计算量，并且提高对文件抽样检查的覆盖率，采用Arbitrum式的多轮交互验证模式。

#### 3.1 提出质疑

DABackend节点提交证明后，将进行第一阶段的证明验证。根据验证公钥`vk`，验证聚合承诺`Cn`、聚合证明`Pn`以及有效随机数`rnd`是否存在有效的配对关系。

无论本轮验证是否通过，都会将上一次提交证明的收益释放给DABackend节点（为了保障资金安全，DABackend节点可以设置一个专用于接收资金的冷账户地址`receiver`）。

如果验证失败，则本次提交证明的收益直接为0。如果验证成功，则先将本次的收益记录下来，等到下一次提交证明时再释放。如果有节点提出质疑，则开启第二阶段，该节点发起挑战，触发欺诈证明，目的是证明DABackend节点存在欺诈行为，如果欺诈行为确实存在，那么本次的收益也会被扣掉（一部分奖励给挑战者，一部分奖励给基金会）。

#### 3.2 多轮交互

节点可以自行选择是否要发起挑战，如果挑战失败（DABackend节点不存在欺诈行为），那么挑战者将白白浪费掉自己的交易费和质押费用（发起挑战时需要质押挑战费）；如果挑战成功（DABackend节点确实存在欺诈行为），那么挑战者将获得回报。这一机制有效减少了文件可用性证明的代价，并且有效遏制了欺诈行为。

当挑战发起后，DABackend节点需要在有效期`respondTime`内进行响应，若没有在有效期内响应，则视为DABackend节点失败，表明DABackend节点存在欺诈行为。DABackend节点若要正常响应，则需要将被挑选的待验证文件按顺序分成十等份，每一份文件的承诺值进行聚合，得到10个聚合承诺值`_cns`，调用`responseChal`方法将`_cns`提交到链上合约中，在合约中进行聚合验证，合约将`_cns`再次聚合，验证其是否和第一阶段中提交的`cn`一致。若一致，则说明在此轮交互中，没有发现DABackend节点的欺诈行为；若不一致，则可以直接证明DABackend节点存在欺诈行为。

若在第一轮交互中没有发现DABackend节点的欺诈行为，那么挑战者可以在`respondTime`内选择发起第二轮交互，具体为：挑战者调用`continueChal`方法，在上一轮的`_cns`中选择一个有问题的聚合承诺值`_cn`，也就是把有问题的文件范围压缩了10倍（用`chalIndex`表示十等份文件中的第几份），针对该部分文件继续挑战DABackend节点。DABackend节点接收到`continueChal`的信号后，仍然需要在`respondTime`内进行响应，继续将`chalIndex`表示的文件按顺序分成十等份，之后的逻辑和上述相同。

一旦发起挑战，DABackend节点和挑战者任一方，没有在有效期`respondTime`内进行响应，都将被视为失败方。

#### 3.3 单步证明

直到最后一轮交互，被挑战的文件范围被压缩至只有几个，此时不需要聚合文件，只需要提交这几个文件的单个承诺值即可。该过程被称为单步证明。DABackend节点只需要调用`oneStepProve`方法，将单个文件的承诺值提交到合约中，合约先验证这些文件的聚合承诺值是否与上一轮的承诺值一致，之后再将这些文件的承诺值一一与链上记录的该文件承诺值进行比对，如果比对成功，则可以最终表明DABackend节点不存在欺诈行为，挑战者将为他的恶意挑战付出代价；如果比对不成功，则表明DABackend节点存在欺诈行为，挑战者将获得回报。
