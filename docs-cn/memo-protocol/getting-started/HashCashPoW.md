# HashCash原理以及Grid中的PoW

## 关于 HashCash

先来思考一个问题：如何写一个能消耗对方时间的程序？

消耗时间还不简单，休眠一下就可以了：

Sleep(1000)
这确实消耗了时间，但并没有消耗 CPU。如果对方开了变速齿轮，这瞬间就能完成。

不过要消耗 CPU 也不难，写一个大循环就可以了：

for i = 0 to 1000000000
end
但这和 Sleep 并无本质区别。对方究竟有没有运行，我们从何得知？

所以，我们需要一个返回结果 —— 只有完整运行才有正确答案。

result = 0
for i = 0 to 1000000000
    result = result + i
end
return result
通过返回结果，我们就能校验，对方是否完整运行了我们的程序。

不过上面这个问题，毕竟还是 too simple。小学生都知道，用数列公式就可以直接算出结果，根本不用花时间去跑循环。

有什么函数，是无法用公式推测的？也就是说，必须老老实实运行函数，才能得出结果。而找不到一种更快的算法，也能算出相同的结果。

显然「单向散列函数」就是。例如，一个经典的问题：

MD5(X) == X
就无法用公式来解决了。要找出答案，只能一个个试过去，需要大量的时间。

但对于验证者，是非常轻松的 —— 只需将收到的答案，计算一次就可判断对错。

Hashcash
当然，上面的那个例子太困难了，一时间根本找不到答案。但可以做一些改进，例如只要求结果前几位是 0 就可以：

Hash(X) == "0000......"
这样 0 的数量越少，满足条件的 X 就越容易找到。

同时，为了防止答案重复使用，还可以再增加一个盐值：

Hash(X, Salt) == "0000......"
盐可以由验证者提供，这样就可以充当一个「问题」。符合条件的 X，则可以当做问题的「答案」，提交给验证者鉴定。

这就是所谓的 PoW（Proof-of-Work），一种鉴定对方是否投入计算工作的机制。并且只需花费少量的资源，即可鉴定大量的工作。

使用散列函数实现的 PoW，就叫做 Hashcash。现实中比特币使用了类似的原理，它使用了 SHA-256 作为散列函数。有权威的密码学算法作为保障，因此只能暴力穷举，而无法使用投机取巧的方法获得结果，保障了挖矿工作的价值。

## Grid 中的 PoW

在Grid项目中，我们使用了类似HashCash的技术来实现PoW。

以下展示了一个计算hash答案的核心方法，它使用了指定的难度和随机值来计算hash值：

```c
void runSha256(int diffcult, int index, BYTE *data, size_t len, long long *result, long long n)
{
    int blockSize = 16;
    int numBlocks = (n + blockSize - 1) / blockSize;

    sha256_cuda<<<numBlocks, blockSize>>>(diffcult, index, data, len, result, n);
}
```

答案基于指定的条件来计算：难度和随机值，并在result参数里返回此答案。

难度和随机值由验证器（validator）提供， 所有节点均向验证器请求这些参数。计算节点必须尝试获取每次挑战的正确的答案，并发送答案到验证器，以验证此算力挑战是否通过。如果计算节点通过了此算力挑战，则表示此计算节点拥有正确的算力，否则计算节点的算力验证失败，因此不能获取对应的Grid算力收益。
